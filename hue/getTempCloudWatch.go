package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/cloudwatch"
)

type AutoGenerated struct {
	Num1 struct {
		State struct {
			Daylight    interface{} `json:"daylight"`
			Lastupdated string      `json:"lastupdated"`
		} `json:"state"`
		Config struct {
			On            bool `json:"on"`
			Configured    bool `json:"configured"`
			Sunriseoffset int  `json:"sunriseoffset"`
			Sunsetoffset  int  `json:"sunsetoffset"`
		} `json:"config"`
		Name             string `json:"name"`
		Type             string `json:"type"`
		Modelid          string `json:"modelid"`
		Manufacturername string `json:"manufacturername"`
		Swversion        string `json:"swversion"`
	} `json:"1"`
	Num2 struct {
		State struct {
			Flag        bool   `json:"flag"`
			Lastupdated string `json:"lastupdated"`
		} `json:"state"`
		Config struct {
			On        bool `json:"on"`
			Reachable bool `json:"reachable"`
		} `json:"config"`
		Name             string `json:"name"`
		Type             string `json:"type"`
		Modelid          string `json:"modelid"`
		Manufacturername string `json:"manufacturername"`
		Swversion        string `json:"swversion"`
		Uniqueid         string `json:"uniqueid"`
		Recycle          bool   `json:"recycle"`
	} `json:"2"`
	Num3 struct {
		State struct {
			Temperature int    `json:"temperature"`
			Lastupdated string `json:"lastupdated"`
		} `json:"state"`
		Config struct {
			On            bool          `json:"on"`
			Battery       int           `json:"battery"`
			Reachable     bool          `json:"reachable"`
			Alert         string        `json:"alert"`
			Ledindication bool          `json:"ledindication"`
			Usertest      bool          `json:"usertest"`
			Pending       []interface{} `json:"pending"`
		} `json:"config"`
		Name             string `json:"name"`
		Type             string `json:"type"`
		Modelid          string `json:"modelid"`
		Manufacturername string `json:"manufacturername"`
		Swversion        string `json:"swversion"`
		Uniqueid         string `json:"uniqueid"`
	} `json:"3"`
	Num4 struct {
		State struct {
			Presence    bool   `json:"presence"`
			Lastupdated string `json:"lastupdated"`
		} `json:"state"`
		Config struct {
			On             bool          `json:"on"`
			Battery        int           `json:"battery"`
			Reachable      bool          `json:"reachable"`
			Alert          string        `json:"alert"`
			Ledindication  bool          `json:"ledindication"`
			Usertest       bool          `json:"usertest"`
			Sensitivity    int           `json:"sensitivity"`
			Sensitivitymax int           `json:"sensitivitymax"`
			Pending        []interface{} `json:"pending"`
		} `json:"config"`
		Name             string `json:"name"`
		Type             string `json:"type"`
		Modelid          string `json:"modelid"`
		Manufacturername string `json:"manufacturername"`
		Swversion        string `json:"swversion"`
		Uniqueid         string `json:"uniqueid"`
	} `json:"4"`
	Num5 struct {
		State struct {
			Lightlevel  int    `json:"lightlevel"`
			Dark        bool   `json:"dark"`
			Daylight    bool   `json:"daylight"`
			Lastupdated string `json:"lastupdated"`
		} `json:"state"`
		Config struct {
			On            bool          `json:"on"`
			Battery       int           `json:"battery"`
			Reachable     bool          `json:"reachable"`
			Alert         string        `json:"alert"`
			Tholddark     int           `json:"tholddark"`
			Tholdoffset   int           `json:"tholdoffset"`
			Ledindication bool          `json:"ledindication"`
			Usertest      bool          `json:"usertest"`
			Pending       []interface{} `json:"pending"`
		} `json:"config"`
		Name             string `json:"name"`
		Type             string `json:"type"`
		Modelid          string `json:"modelid"`
		Manufacturername string `json:"manufacturername"`
		Swversion        string `json:"swversion"`
		Uniqueid         string `json:"uniqueid"`
	} `json:"5"`
	Num6 struct {
		State struct {
			Status      int    `json:"status"`
			Lastupdated string `json:"lastupdated"`
		} `json:"state"`
		Config struct {
			On        bool `json:"on"`
			Reachable bool `json:"reachable"`
		} `json:"config"`
		Name             string `json:"name"`
		Type             string `json:"type"`
		Modelid          string `json:"modelid"`
		Manufacturername string `json:"manufacturername"`
		Swversion        string `json:"swversion"`
		Uniqueid         string `json:"uniqueid"`
		Recycle          bool   `json:"recycle"`
	} `json:"6"`
}

func main() {
	for {
		ch := make(chan string)
		go readSensorsData(ch)
		//var sensorsData = readSensorsData()
		sensorsData := <-ch

		var jsono AutoGenerated
		json.Unmarshal([]byte(sensorsData), &jsono)
		var temperature = float64(jsono.Num3.State.Temperature)
		fmt.Printf("Temperature: %#v\n", temperature)

		pushCloudwatch(temperature)
		time.Sleep(time.Second * 60)
	}
}

func pushCloudwatch(temperature float64) {
	sess, err := session.NewSession()
	if err != nil {
		fmt.Println("failed to create session,", err)
		return
	}

	svc := cloudwatch.New(sess, &aws.Config{Region: aws.String("eu-west-1")})

	params := &cloudwatch.PutMetricDataInput{
		MetricData: []*cloudwatch.MetricDatum{
			{
				MetricName: aws.String("Temperature"),
				/*Dimensions: []*cloudwatch.Dimension{
					{
						Name:  aws.String("Temperatura"),
						Value: aws.String("Celsius"),
					},
				},*/
				Timestamp: aws.Time(time.Now()),
				Unit:      aws.String("Count"),
				Value:     aws.Float64(temperature),
			},
		},
		Namespace: aws.String("Home"), // Required
	}
	resp, err := svc.PutMetricData(params)

	if err != nil {
		// Print the error, cast err to awserr.Error to get the Code and
		// Message from an error.
		fmt.Println(err.Error())
		return
	}

	// Pretty-print the response data.
	fmt.Sprintln(resp)
}

func readSensorsData(ch chan string) string {

	url := "http://BRIDGE_IP/api/TOKEN/sensors"
	req, err := http.NewRequest("GET", url, nil)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)
	ch <- string(body)

	return string(body)
}

func checkError(message string, err error) {
	if err != nil {
		log.Fatal(message, err)
	}
}
